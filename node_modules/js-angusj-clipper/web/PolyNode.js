"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolyNode = void 0;
var PathToNativePath_1 = require("./native/PathToNativePath");
/**
 * PolyNodes are encapsulated within a PolyTree container, and together provide a data structure representing the parent-child relationships of polygon
 * contours returned by clipping/ofsetting methods.
 *
 * A PolyNode object represents a single polygon. It's isHole property indicates whether it's an outer or a hole. PolyNodes may own any number of PolyNode
 * children (childs), where children of outer polygons are holes, and children of holes are (nested) outer polygons.
 */
var PolyNode = /** @class */ (function () {
    function PolyNode() {
        this._childs = [];
        this._contour = [];
        this._isOpen = false;
        this._index = 0;
    }
    Object.defineProperty(PolyNode.prototype, "parent", {
        /**
         * Returns the parent PolyNode.
         *
         * The PolyTree object (which is also a PolyNode) does not have a parent and will return undefined.
         */
        get: function () {
            return this._parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PolyNode.prototype, "childs", {
        /**
         * A read-only list of PolyNode.
         * Outer PolyNode childs contain hole PolyNodes, and hole PolyNode childs contain nested outer PolyNodes.
         */
        get: function () {
            return this._childs;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PolyNode.prototype, "contour", {
        /**
         * Returns a path list which contains any number of vertices.
         */
        get: function () {
            return this._contour;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PolyNode.prototype, "isOpen", {
        /**
         * Returns true when the PolyNode's Contour results from a clipping operation on an open contour (path). Only top-level PolyNodes can contain open contours.
         */
        get: function () {
            return this._isOpen;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PolyNode.prototype, "index", {
        /**
         * Index in the parent's child list, or 0 if no parent.
         */
        get: function () {
            return this._index;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PolyNode.prototype, "isHole", {
        /**
         * Returns true when the PolyNode's polygon (Contour) is a hole.
         *
         * Children of outer polygons are always holes, and children of holes are always (nested) outer polygons.
         * The isHole property of a PolyTree object is undefined but its children are always top-level outer polygons.
         *
         * @return {boolean}
         */
        get: function () {
            if (this._isHole === undefined) {
                var result = true;
                var node = this._parent;
                while (node !== undefined) {
                    result = !result;
                    node = node._parent;
                }
                this._isHole = result;
            }
            return this._isHole;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * The returned PolyNode will be the first child if any, otherwise the next sibling, otherwise the next sibling of the Parent etc.
     *
     * A PolyTree can be traversed very easily by calling GetFirst() followed by GetNext() in a loop until the returned object is undefined.
     *
     * @return {PolyNode | undefined}
     */
    PolyNode.prototype.getNext = function () {
        if (this._childs.length > 0) {
            return this._childs[0];
        }
        else {
            return this.getNextSiblingUp();
        }
    };
    PolyNode.prototype.getNextSiblingUp = function () {
        if (this._parent === undefined) {
            return undefined;
        }
        else if (this._index === this._parent._childs.length - 1) {
            //noinspection TailRecursionJS
            return this._parent.getNextSiblingUp();
        }
        else {
            return this._parent._childs[this._index + 1];
        }
    };
    PolyNode.fillFromNativePolyNode = function (pn, nativeLib, nativePolyNode, parent, childIndex, freeNativePolyNode) {
        pn._parent = parent;
        var childs = nativePolyNode.childs;
        for (var i = 0, max = childs.size(); i < max; i++) {
            var newChild = PolyNode.fromNativePolyNode(nativeLib, childs.get(i), pn, i, freeNativePolyNode);
            pn._childs.push(newChild);
        }
        // do we need to clear the object ourselves? for now let's assume so (seems to work)
        pn._contour = (0, PathToNativePath_1.nativePathToPath)(nativeLib, nativePolyNode.contour, true);
        pn._isOpen = nativePolyNode.isOpen();
        pn._index = childIndex;
        if (freeNativePolyNode) {
            nativePolyNode.delete();
        }
    };
    PolyNode.fromNativePolyNode = function (nativeLib, nativePolyNode, parent, childIndex, freeNativePolyNode) {
        var pn = new PolyNode();
        PolyNode.fillFromNativePolyNode(pn, nativeLib, nativePolyNode, parent, childIndex, freeNativePolyNode);
        return pn;
    };
    return PolyNode;
}());
exports.PolyNode = PolyNode;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUG9seU5vZGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvUG9seU5vZGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBRUEsOERBQTZEO0FBRzdEOzs7Ozs7R0FNRztBQUNIO0lBQUE7UUFZWSxZQUFPLEdBQWUsRUFBRSxDQUFDO1FBU3pCLGFBQVEsR0FBaUIsRUFBRSxDQUFDO1FBUTVCLFlBQU8sR0FBRyxLQUFLLENBQUM7UUFRaEIsV0FBTSxHQUFHLENBQUMsQ0FBQztJQTJHdkIsQ0FBQztJQXhJQyxzQkFBSSw0QkFBTTtRQUxWOzs7O1dBSUc7YUFDSDtZQUNFLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUN0QixDQUFDOzs7T0FBQTtJQU9ELHNCQUFJLDRCQUFNO1FBSlY7OztXQUdHO2FBQ0g7WUFDRSxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDdEIsQ0FBQzs7O09BQUE7SUFNRCxzQkFBSSw2QkFBTztRQUhYOztXQUVHO2FBQ0g7WUFDRSxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDdkIsQ0FBQzs7O09BQUE7SUFNRCxzQkFBSSw0QkFBTTtRQUhWOztXQUVHO2FBQ0g7WUFDRSxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDdEIsQ0FBQzs7O09BQUE7SUFNRCxzQkFBSSwyQkFBSztRQUhUOztXQUVHO2FBQ0g7WUFDRSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDckIsQ0FBQzs7O09BQUE7SUFXRCxzQkFBSSw0QkFBTTtRQVJWOzs7Ozs7O1dBT0c7YUFDSDtZQUNFLElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxTQUFTLEVBQUU7Z0JBQzlCLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQztnQkFDbEIsSUFBSSxJQUFJLEdBQXlCLElBQUksQ0FBQyxPQUFPLENBQUM7Z0JBQzlDLE9BQU8sSUFBSSxLQUFLLFNBQVMsRUFBRTtvQkFDekIsTUFBTSxHQUFHLENBQUMsTUFBTSxDQUFDO29CQUNqQixJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztpQkFDckI7Z0JBQ0QsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7YUFDdkI7WUFFRCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDdEIsQ0FBQzs7O09BQUE7SUFFRDs7Ozs7O09BTUc7SUFDSCwwQkFBTyxHQUFQO1FBQ0UsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDM0IsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3hCO2FBQU07WUFDTCxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1NBQ2hDO0lBQ0gsQ0FBQztJQUVTLG1DQUFnQixHQUExQjtRQUNFLElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxTQUFTLEVBQUU7WUFDOUIsT0FBTyxTQUFTLENBQUM7U0FDbEI7YUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUMxRCw4QkFBOEI7WUFDOUIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLGdCQUFnQixFQUFFLENBQUM7U0FDeEM7YUFBTTtZQUNMLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztTQUM5QztJQUNILENBQUM7SUFFZ0IsK0JBQXNCLEdBQXZDLFVBQ0UsRUFBWSxFQUNaLFNBQW1DLEVBQ25DLGNBQThCLEVBQzlCLE1BQTRCLEVBQzVCLFVBQWtCLEVBQ2xCLGtCQUEyQjtRQUUzQixFQUFFLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztRQUVwQixJQUFNLE1BQU0sR0FBRyxjQUFjLENBQUMsTUFBTSxDQUFDO1FBQ3JDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxNQUFNLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNqRCxJQUFNLFFBQVEsR0FBRyxRQUFRLENBQUMsa0JBQWtCLENBQzFDLFNBQVMsRUFDVCxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUNiLEVBQUUsRUFDRixDQUFDLEVBQ0Qsa0JBQWtCLENBQ25CLENBQUM7WUFDRixFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUMzQjtRQUVELG9GQUFvRjtRQUNwRixFQUFFLENBQUMsUUFBUSxHQUFHLElBQUEsbUNBQWdCLEVBQUMsU0FBUyxFQUFFLGNBQWMsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDeEUsRUFBRSxDQUFDLE9BQU8sR0FBRyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDckMsRUFBRSxDQUFDLE1BQU0sR0FBRyxVQUFVLENBQUM7UUFFdkIsSUFBSSxrQkFBa0IsRUFBRTtZQUN0QixjQUFjLENBQUMsTUFBTSxFQUFFLENBQUM7U0FDekI7SUFDSCxDQUFDO0lBRWdCLDJCQUFrQixHQUFuQyxVQUNFLFNBQW1DLEVBQ25DLGNBQThCLEVBQzlCLE1BQTRCLEVBQzVCLFVBQWtCLEVBQ2xCLGtCQUEyQjtRQUUzQixJQUFNLEVBQUUsR0FBRyxJQUFJLFFBQVEsRUFBRSxDQUFDO1FBQzFCLFFBQVEsQ0FBQyxzQkFBc0IsQ0FDN0IsRUFBRSxFQUNGLFNBQVMsRUFDVCxjQUFjLEVBQ2QsTUFBTSxFQUNOLFVBQVUsRUFDVixrQkFBa0IsQ0FDbkIsQ0FBQztRQUNGLE9BQU8sRUFBRSxDQUFDO0lBQ1osQ0FBQztJQUNILGVBQUM7QUFBRCxDQUFDLEFBaEpELElBZ0pDO0FBaEpZLDRCQUFRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmF0aXZlQ2xpcHBlckxpYkluc3RhbmNlIH0gZnJvbSBcIi4vbmF0aXZlL05hdGl2ZUNsaXBwZXJMaWJJbnN0YW5jZVwiO1xuaW1wb3J0IHsgTmF0aXZlUG9seU5vZGUgfSBmcm9tIFwiLi9uYXRpdmUvTmF0aXZlUG9seU5vZGVcIjtcbmltcG9ydCB7IG5hdGl2ZVBhdGhUb1BhdGggfSBmcm9tIFwiLi9uYXRpdmUvUGF0aFRvTmF0aXZlUGF0aFwiO1xuaW1wb3J0IHsgUmVhZG9ubHlQYXRoIH0gZnJvbSBcIi4vUGF0aFwiO1xuXG4vKipcbiAqIFBvbHlOb2RlcyBhcmUgZW5jYXBzdWxhdGVkIHdpdGhpbiBhIFBvbHlUcmVlIGNvbnRhaW5lciwgYW5kIHRvZ2V0aGVyIHByb3ZpZGUgYSBkYXRhIHN0cnVjdHVyZSByZXByZXNlbnRpbmcgdGhlIHBhcmVudC1jaGlsZCByZWxhdGlvbnNoaXBzIG9mIHBvbHlnb25cbiAqIGNvbnRvdXJzIHJldHVybmVkIGJ5IGNsaXBwaW5nL29mc2V0dGluZyBtZXRob2RzLlxuICpcbiAqIEEgUG9seU5vZGUgb2JqZWN0IHJlcHJlc2VudHMgYSBzaW5nbGUgcG9seWdvbi4gSXQncyBpc0hvbGUgcHJvcGVydHkgaW5kaWNhdGVzIHdoZXRoZXIgaXQncyBhbiBvdXRlciBvciBhIGhvbGUuIFBvbHlOb2RlcyBtYXkgb3duIGFueSBudW1iZXIgb2YgUG9seU5vZGVcbiAqIGNoaWxkcmVuIChjaGlsZHMpLCB3aGVyZSBjaGlsZHJlbiBvZiBvdXRlciBwb2x5Z29ucyBhcmUgaG9sZXMsIGFuZCBjaGlsZHJlbiBvZiBob2xlcyBhcmUgKG5lc3RlZCkgb3V0ZXIgcG9seWdvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2x5Tm9kZSB7XG4gIHByb3RlY3RlZCBfcGFyZW50PzogUG9seU5vZGU7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhcmVudCBQb2x5Tm9kZS5cbiAgICpcbiAgICogVGhlIFBvbHlUcmVlIG9iamVjdCAod2hpY2ggaXMgYWxzbyBhIFBvbHlOb2RlKSBkb2VzIG5vdCBoYXZlIGEgcGFyZW50IGFuZCB3aWxsIHJldHVybiB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgcGFyZW50KCk6IFBvbHlOb2RlIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jaGlsZHM6IFBvbHlOb2RlW10gPSBbXTtcbiAgLyoqXG4gICAqIEEgcmVhZC1vbmx5IGxpc3Qgb2YgUG9seU5vZGUuXG4gICAqIE91dGVyIFBvbHlOb2RlIGNoaWxkcyBjb250YWluIGhvbGUgUG9seU5vZGVzLCBhbmQgaG9sZSBQb2x5Tm9kZSBjaGlsZHMgY29udGFpbiBuZXN0ZWQgb3V0ZXIgUG9seU5vZGVzLlxuICAgKi9cbiAgZ2V0IGNoaWxkcygpOiBQb2x5Tm9kZVtdIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRzO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jb250b3VyOiBSZWFkb25seVBhdGggPSBbXTtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBwYXRoIGxpc3Qgd2hpY2ggY29udGFpbnMgYW55IG51bWJlciBvZiB2ZXJ0aWNlcy5cbiAgICovXG4gIGdldCBjb250b3VyKCk6IFJlYWRvbmx5UGF0aCB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRvdXI7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2lzT3BlbiA9IGZhbHNlO1xuICAvKipcbiAgICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIFBvbHlOb2RlJ3MgQ29udG91ciByZXN1bHRzIGZyb20gYSBjbGlwcGluZyBvcGVyYXRpb24gb24gYW4gb3BlbiBjb250b3VyIChwYXRoKS4gT25seSB0b3AtbGV2ZWwgUG9seU5vZGVzIGNhbiBjb250YWluIG9wZW4gY29udG91cnMuXG4gICAqL1xuICBnZXQgaXNPcGVuKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9pc09wZW47XG4gIH1cblxuICBwcm90ZWN0ZWQgX2luZGV4ID0gMDtcbiAgLyoqXG4gICAqIEluZGV4IGluIHRoZSBwYXJlbnQncyBjaGlsZCBsaXN0LCBvciAwIGlmIG5vIHBhcmVudC5cbiAgICovXG4gIGdldCBpbmRleCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9pbmRleDtcbiAgfVxuXG4gIHByb3RlY3RlZCBfaXNIb2xlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBQb2x5Tm9kZSdzIHBvbHlnb24gKENvbnRvdXIpIGlzIGEgaG9sZS5cbiAgICpcbiAgICogQ2hpbGRyZW4gb2Ygb3V0ZXIgcG9seWdvbnMgYXJlIGFsd2F5cyBob2xlcywgYW5kIGNoaWxkcmVuIG9mIGhvbGVzIGFyZSBhbHdheXMgKG5lc3RlZCkgb3V0ZXIgcG9seWdvbnMuXG4gICAqIFRoZSBpc0hvbGUgcHJvcGVydHkgb2YgYSBQb2x5VHJlZSBvYmplY3QgaXMgdW5kZWZpbmVkIGJ1dCBpdHMgY2hpbGRyZW4gYXJlIGFsd2F5cyB0b3AtbGV2ZWwgb3V0ZXIgcG9seWdvbnMuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNIb2xlKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLl9pc0hvbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IHJlc3VsdCA9IHRydWU7XG4gICAgICBsZXQgbm9kZTogUG9seU5vZGUgfCB1bmRlZmluZWQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICB3aGlsZSAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCA9ICFyZXN1bHQ7XG4gICAgICAgIG5vZGUgPSBub2RlLl9wYXJlbnQ7XG4gICAgICB9XG4gICAgICB0aGlzLl9pc0hvbGUgPSByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2lzSG9sZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcmV0dXJuZWQgUG9seU5vZGUgd2lsbCBiZSB0aGUgZmlyc3QgY2hpbGQgaWYgYW55LCBvdGhlcndpc2UgdGhlIG5leHQgc2libGluZywgb3RoZXJ3aXNlIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIFBhcmVudCBldGMuXG4gICAqXG4gICAqIEEgUG9seVRyZWUgY2FuIGJlIHRyYXZlcnNlZCB2ZXJ5IGVhc2lseSBieSBjYWxsaW5nIEdldEZpcnN0KCkgZm9sbG93ZWQgYnkgR2V0TmV4dCgpIGluIGEgbG9vcCB1bnRpbCB0aGUgcmV0dXJuZWQgb2JqZWN0IGlzIHVuZGVmaW5lZC5cbiAgICpcbiAgICogQHJldHVybiB7UG9seU5vZGUgfCB1bmRlZmluZWR9XG4gICAqL1xuICBnZXROZXh0KCk6IFBvbHlOb2RlIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAodGhpcy5fY2hpbGRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaGlsZHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE5leHRTaWJsaW5nVXAoKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0TmV4dFNpYmxpbmdVcCgpOiBQb2x5Tm9kZSB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHRoaXMuX3BhcmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5faW5kZXggPT09IHRoaXMuX3BhcmVudC5fY2hpbGRzLmxlbmd0aCAtIDEpIHtcbiAgICAgIC8vbm9pbnNwZWN0aW9uIFRhaWxSZWN1cnNpb25KU1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudC5nZXROZXh0U2libGluZ1VwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQuX2NoaWxkc1t0aGlzLl9pbmRleCArIDFdO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBzdGF0aWMgZmlsbEZyb21OYXRpdmVQb2x5Tm9kZShcbiAgICBwbjogUG9seU5vZGUsXG4gICAgbmF0aXZlTGliOiBOYXRpdmVDbGlwcGVyTGliSW5zdGFuY2UsXG4gICAgbmF0aXZlUG9seU5vZGU6IE5hdGl2ZVBvbHlOb2RlLFxuICAgIHBhcmVudDogUG9seU5vZGUgfCB1bmRlZmluZWQsXG4gICAgY2hpbGRJbmRleDogbnVtYmVyLFxuICAgIGZyZWVOYXRpdmVQb2x5Tm9kZTogYm9vbGVhblxuICApOiB2b2lkIHtcbiAgICBwbi5fcGFyZW50ID0gcGFyZW50O1xuXG4gICAgY29uc3QgY2hpbGRzID0gbmF0aXZlUG9seU5vZGUuY2hpbGRzO1xuICAgIGZvciAobGV0IGkgPSAwLCBtYXggPSBjaGlsZHMuc2l6ZSgpOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgIGNvbnN0IG5ld0NoaWxkID0gUG9seU5vZGUuZnJvbU5hdGl2ZVBvbHlOb2RlKFxuICAgICAgICBuYXRpdmVMaWIsXG4gICAgICAgIGNoaWxkcy5nZXQoaSksXG4gICAgICAgIHBuLFxuICAgICAgICBpLFxuICAgICAgICBmcmVlTmF0aXZlUG9seU5vZGVcbiAgICAgICk7XG4gICAgICBwbi5fY2hpbGRzLnB1c2gobmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIC8vIGRvIHdlIG5lZWQgdG8gY2xlYXIgdGhlIG9iamVjdCBvdXJzZWx2ZXM/IGZvciBub3cgbGV0J3MgYXNzdW1lIHNvIChzZWVtcyB0byB3b3JrKVxuICAgIHBuLl9jb250b3VyID0gbmF0aXZlUGF0aFRvUGF0aChuYXRpdmVMaWIsIG5hdGl2ZVBvbHlOb2RlLmNvbnRvdXIsIHRydWUpO1xuICAgIHBuLl9pc09wZW4gPSBuYXRpdmVQb2x5Tm9kZS5pc09wZW4oKTtcbiAgICBwbi5faW5kZXggPSBjaGlsZEluZGV4O1xuXG4gICAgaWYgKGZyZWVOYXRpdmVQb2x5Tm9kZSkge1xuICAgICAgbmF0aXZlUG9seU5vZGUuZGVsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIHN0YXRpYyBmcm9tTmF0aXZlUG9seU5vZGUoXG4gICAgbmF0aXZlTGliOiBOYXRpdmVDbGlwcGVyTGliSW5zdGFuY2UsXG4gICAgbmF0aXZlUG9seU5vZGU6IE5hdGl2ZVBvbHlOb2RlLFxuICAgIHBhcmVudDogUG9seU5vZGUgfCB1bmRlZmluZWQsXG4gICAgY2hpbGRJbmRleDogbnVtYmVyLFxuICAgIGZyZWVOYXRpdmVQb2x5Tm9kZTogYm9vbGVhblxuICApOiBQb2x5Tm9kZSB7XG4gICAgY29uc3QgcG4gPSBuZXcgUG9seU5vZGUoKTtcbiAgICBQb2x5Tm9kZS5maWxsRnJvbU5hdGl2ZVBvbHlOb2RlKFxuICAgICAgcG4sXG4gICAgICBuYXRpdmVMaWIsXG4gICAgICBuYXRpdmVQb2x5Tm9kZSxcbiAgICAgIHBhcmVudCxcbiAgICAgIGNoaWxkSW5kZXgsXG4gICAgICBmcmVlTmF0aXZlUG9seU5vZGVcbiAgICApO1xuICAgIHJldHVybiBwbjtcbiAgfVxufVxuIl19