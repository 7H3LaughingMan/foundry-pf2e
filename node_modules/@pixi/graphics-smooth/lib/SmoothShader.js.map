{"version":3,"file":"SmoothShader.js","sources":["../src/SmoothShader.ts"],"sourcesContent":["import { Program, Shader } from '@pixi/core';\r\nimport { IGraphicsBatchSettings } from './core/BatchDrawCall';\r\n\r\nconst smoothVert = `#version 100\r\nprecision highp float;\r\nconst float FILL = 1.0;\r\nconst float BEVEL = 4.0;\r\nconst float MITER = 8.0;\r\nconst float ROUND = 12.0;\r\nconst float JOINT_CAP_BUTT = 16.0;\r\nconst float JOINT_CAP_SQUARE = 18.0;\r\nconst float JOINT_CAP_ROUND = 20.0;\r\n\r\nconst float FILL_EXPAND = 24.0;\r\n\r\nconst float CAP_BUTT = 1.0;\r\nconst float CAP_SQUARE = 2.0;\r\nconst float CAP_ROUND = 3.0;\r\nconst float CAP_BUTT2 = 4.0;\r\n\r\nconst float MITER_LIMIT = 10.0;\r\n\r\n// === geom ===\r\nattribute vec2 aPrev;\r\nattribute vec2 aPoint1;\r\nattribute vec2 aPoint2;\r\nattribute vec2 aNext;\r\nattribute float aVertexJoint;\r\nattribute float aTravel;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform vec4 tint;\r\n\r\nvarying vec4 vLine1;\r\nvarying vec4 vLine2;\r\nvarying vec4 vArc;\r\nvarying float vType;\r\n\r\nuniform float resolution;\r\nuniform float expand;\r\n\r\n// === style ===\r\nattribute float aStyleId;\r\nattribute vec4 aColor;\r\n\r\nvarying float vTextureId;\r\nvarying vec4 vColor;\r\nvarying vec2 vTextureCoord;\r\nvarying vec2 vTravel;\r\n\r\nuniform vec2 styleLine[%MAX_STYLES%];\r\nuniform vec3 styleMatrix[2 * %MAX_STYLES%];\r\nuniform float styleTextureId[%MAX_STYLES%];\r\nuniform vec2 samplerSize[%MAX_TEXTURES%];\r\n\r\nvec2 doBisect(vec2 norm, float len, vec2 norm2, float len2,\r\n    float dy, float inner) {\r\n    vec2 bisect = (norm + norm2) / 2.0;\r\n    bisect /= dot(norm, bisect);\r\n    vec2 shift = dy * bisect;\r\n    if (inner > 0.5) {\r\n        if (len < len2) {\r\n            if (abs(dy * (bisect.x * norm.y - bisect.y * norm.x)) > len) {\r\n                return dy * norm;\r\n            }\r\n        } else {\r\n            if (abs(dy * (bisect.x * norm2.y - bisect.y * norm2.x)) > len2) {\r\n                return dy * norm;\r\n            }\r\n        }\r\n    }\r\n    return dy * bisect;\r\n}\r\n\r\nvoid main(void){\r\n    vec2 pointA = (translationMatrix * vec3(aPoint1, 1.0)).xy;\r\n    vec2 pointB = (translationMatrix * vec3(aPoint2, 1.0)).xy;\r\n\r\n    vec2 xBasis = pointB - pointA;\r\n    float len = length(xBasis);\r\n    vec2 forward = xBasis / len;\r\n    vec2 norm = vec2(forward.y, -forward.x);\r\n\r\n    float type = floor(aVertexJoint / 16.0);\r\n    float vertexNum = aVertexJoint - type * 16.0;\r\n    float dx = 0.0, dy = 1.0;\r\n\r\n    float capType = floor(type / 32.0);\r\n    type -= capType * 32.0;\r\n\r\n    int styleId = int(aStyleId + 0.5);\r\n    float lineWidth = styleLine[styleId].x;\r\n    vTextureId = floor(styleTextureId[styleId] / 4.0);\r\n    float scaleMode = styleTextureId[styleId] - vTextureId * 4.0;\r\n    float avgScale = 1.0;\r\n    if (scaleMode > 2.5) {\r\n        avgScale = length(translationMatrix * vec3(1.0, 0.0, 0.0));\r\n    } else if (scaleMode > 1.5) {\r\n        avgScale = length(translationMatrix * vec3(0.0, 1.0, 0.0));\r\n    } else if (scaleMode > 0.5) {\r\n        vec2 avgDiag = (translationMatrix * vec3(1.0, 1.0, 0.0)).xy;\r\n        avgScale = sqrt(dot(avgDiag, avgDiag) * 0.5);\r\n    }\r\n    lineWidth *= 0.5 * avgScale;\r\n    float lineAlignment = 2.0 * styleLine[styleId].y - 1.0;\r\n    vTextureCoord = vec2(0.0);\r\n\r\n    vec2 pos;\r\n\r\n    if (capType == CAP_ROUND) {\r\n        vertexNum += 4.0;\r\n        type = JOINT_CAP_ROUND;\r\n        capType = 0.0;\r\n        lineAlignment = -lineAlignment;\r\n    }\r\n\r\n    vLine1 = vec4(0.0, 10.0, 1.0, 0.0);\r\n    vLine2 = vec4(0.0, 10.0, 1.0, 0.0);\r\n    vArc = vec4(0.0);\r\n    if (type == FILL) {\r\n        pos = pointA;\r\n        vType = 0.0;\r\n        vLine2 = vec4(-2.0, -2.0, -2.0, 0.0);\r\n        vec2 vTexturePixel;\r\n        vTexturePixel.x = dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2]);\r\n        vTexturePixel.y = dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2 + 1]);\r\n        vTextureCoord = vTexturePixel / samplerSize[int(vTextureId)];\r\n    } else if (type >= FILL_EXPAND && type < FILL_EXPAND + 7.5) {\r\n        // expand vertices\r\n        float flags = type - FILL_EXPAND;\r\n        float flag3 = floor(flags / 4.0);\r\n        float flag2 = floor((flags - flag3 * 4.0) / 2.0);\r\n        float flag1 = flags - flag3 * 4.0 - flag2 * 2.0;\r\n\r\n        vec2 prev = (translationMatrix * vec3(aPrev, 1.0)).xy;\r\n\r\n        if (vertexNum < 0.5) {\r\n            pos = prev;\r\n        } else if (vertexNum < 1.5) {\r\n            pos = pointA;\r\n        } else {\r\n            pos = pointB;\r\n        }\r\n        float len2 = length(aNext);\r\n        vec2 bisect = (translationMatrix * vec3(aNext, 0.0)).xy;\r\n        if (len2 > 0.01) {\r\n            bisect = normalize(bisect) * len2;\r\n        }\r\n\r\n        vec2 n1 = normalize(vec2(pointA.y - prev.y, -(pointA.x - prev.x)));\r\n        vec2 n2 = normalize(vec2(pointB.y - pointA.y, -(pointB.x - pointA.x)));\r\n        vec2 n3 = normalize(vec2(prev.y - pointB.y, -(prev.x - pointB.x)));\r\n\r\n        if (n1.x * n2.y - n1.y * n2.x < 0.0) {\r\n            n1 = -n1;\r\n            n2 = -n2;\r\n            n3 = -n3;\r\n        }\r\n        pos += bisect * expand;\r\n\r\n        vLine1 = vec4(16.0, 16.0, 16.0, -1.0);\r\n        if (flag1 > 0.5) {\r\n            vLine1.x = -dot(pos - prev, n1);\r\n        }\r\n        if (flag2 > 0.5) {\r\n            vLine1.y = -dot(pos - pointA, n2);\r\n        }\r\n        if (flag3 > 0.5) {\r\n            vLine1.z = -dot(pos - pointB, n3);\r\n        }\r\n        vLine1.xyz *= resolution;\r\n        vType = 2.0;\r\n    } else if (type >= BEVEL) {\r\n        float dy = lineWidth + expand;\r\n        float shift = lineWidth * lineAlignment;\r\n        float inner = 0.0;\r\n        if (vertexNum >= 1.5) {\r\n            dy = -dy;\r\n            inner = 1.0;\r\n        }\r\n\r\n        vec2 base, next, xBasis2, bisect;\r\n        float flag = 0.0;\r\n        float side2 = 1.0;\r\n        if (vertexNum < 0.5 || vertexNum > 2.5 && vertexNum < 3.5) {\r\n            next = (translationMatrix * vec3(aPrev, 1.0)).xy;\r\n            base = pointA;\r\n            flag = type - floor(type / 2.0) * 2.0;\r\n            side2 = -1.0;\r\n        } else {\r\n            next = (translationMatrix * vec3(aNext, 1.0)).xy;\r\n            base = pointB;\r\n            if (type >= MITER && type < MITER + 3.5) {\r\n                flag = step(MITER + 1.5, type);\r\n                // check miter limit here?\r\n            }\r\n        }\r\n        xBasis2 = next - base;\r\n        float len2 = length(xBasis2);\r\n        vec2 norm2 = vec2(xBasis2.y, -xBasis2.x) / len2;\r\n        float D = norm.x * norm2.y - norm.y * norm2.x;\r\n        if (D < 0.0) {\r\n            inner = 1.0 - inner;\r\n        }\r\n\r\n        norm2 *= side2;\r\n\r\n        float collinear = step(0.0, dot(norm, norm2));\r\n\r\n        vType = 0.0;\r\n        float dy2 = -1000.0;\r\n\r\n        if (abs(D) < 0.01 && collinear < 0.5) {\r\n            if (type >= ROUND && type < ROUND + 1.5) {\r\n                type = JOINT_CAP_ROUND;\r\n            }\r\n            //TODO: BUTT here too\r\n        }\r\n\r\n        vLine1 = vec4(0.0, lineWidth, max(abs(norm.x), abs(norm.y)), min(abs(norm.x), abs(norm.y)));\r\n        vLine2 = vec4(0.0, lineWidth, max(abs(norm2.x), abs(norm2.y)), min(abs(norm2.x), abs(norm2.y)));\r\n\r\n        if (vertexNum < 3.5) {\r\n            if (abs(D) < 0.01 && collinear < 0.5) {\r\n                pos = (shift + dy) * norm;\r\n            } else {\r\n                if (flag < 0.5 && inner < 0.5) {\r\n                    pos = (shift + dy) * norm;\r\n                } else {\r\n                    pos = doBisect(norm, len, norm2, len2, shift + dy, inner);\r\n                }\r\n            }\r\n            vLine2.y = -1000.0;\r\n            if (capType >= CAP_BUTT && capType < CAP_ROUND) {\r\n                float extra = step(CAP_SQUARE, capType) * lineWidth;\r\n                vec2 back = -forward;\r\n                if (vertexNum < 0.5 || vertexNum > 2.5) {\r\n                    pos += back * (expand + extra);\r\n                    dy2 = expand;\r\n                } else {\r\n                    dy2 = dot(pos + base - pointA, back) - extra;\r\n                }\r\n            }\r\n            if (type >= JOINT_CAP_BUTT && type < JOINT_CAP_SQUARE + 0.5) {\r\n                float extra = step(JOINT_CAP_SQUARE, type) * lineWidth;\r\n                if (vertexNum < 0.5 || vertexNum > 2.5) {\r\n                    vLine2.y = dot(pos + base - pointB, forward) - extra;\r\n                } else {\r\n                    pos += forward * (expand + extra);\r\n                    vLine2.y = expand;\r\n                    if (capType >= CAP_BUTT) {\r\n                        dy2 -= expand + extra;\r\n                    }\r\n                }\r\n            }\r\n        } else if (type >= JOINT_CAP_ROUND && type < JOINT_CAP_ROUND + 1.5) {\r\n            base += shift * norm;\r\n            if (inner > 0.5) {\r\n                dy = -dy;\r\n                inner = 0.0;\r\n            }\r\n            vec2 d2 = abs(dy) * forward;\r\n            if (vertexNum < 4.5) {\r\n                dy = -dy;\r\n                pos = dy * norm;\r\n            } else if (vertexNum < 5.5) {\r\n                pos = dy * norm;\r\n            } else if (vertexNum < 6.5) {\r\n                pos = dy * norm + d2;\r\n                vArc.x = abs(dy);\r\n            } else {\r\n                dy = -dy;\r\n                pos = dy * norm + d2;\r\n                vArc.x = abs(dy);\r\n            }\r\n            vLine2 = vec4(0.0, lineWidth * 2.0 + 10.0, 1.0  , 0.0); // forget about line2 with type=3\r\n            vArc.y = dy;\r\n            vArc.z = 0.0;\r\n            vArc.w = lineWidth;\r\n            vType = 3.0;\r\n        } else if (abs(D) < 0.01 && collinear < 0.5) {\r\n            pos = dy * norm;\r\n        } else {\r\n            if (inner > 0.5) {\r\n                dy = -dy;\r\n                inner = 0.0;\r\n            }\r\n            float side = sign(dy);\r\n            vec2 norm3 = normalize(norm + norm2);\r\n\r\n            if (type >= MITER && type < MITER + 3.5) {\r\n                vec2 farVertex = doBisect(norm, len, norm2, len2, shift + dy, 0.0);\r\n                if (length(farVertex) > abs(shift + dy) * MITER_LIMIT) {\r\n                    type = BEVEL;\r\n                }\r\n            }\r\n\r\n            if (vertexNum < 4.5) {\r\n                pos = doBisect(norm, len, norm2, len2, shift - dy, 1.0);\r\n            } else if (vertexNum < 5.5) {\r\n                pos = (shift + dy) * norm;\r\n            } else if (vertexNum > 7.5) {\r\n                pos = (shift + dy) * norm2;\r\n            } else {\r\n                if (type >= ROUND && type < ROUND + 1.5) {\r\n                    pos = doBisect(norm, len, norm2, len2, shift + dy, 0.0);\r\n                    float d2 = abs(shift + dy);\r\n                    if (length(pos) > abs(shift + dy) * 1.5) {\r\n                        if (vertexNum < 6.5) {\r\n                            pos.x = (shift + dy) * norm.x - d2 * norm.y;\r\n                            pos.y = (shift + dy) * norm.y + d2 * norm.x;\r\n                        } else {\r\n                            pos.x = (shift + dy) * norm2.x + d2 * norm2.y;\r\n                            pos.y = (shift + dy) * norm2.y - d2 * norm2.x;\r\n                        }\r\n                    }\r\n                } else if (type >= MITER && type < MITER + 3.5) {\r\n                    pos = doBisect(norm, len, norm2, len2, shift + dy, 0.0); //farVertex\r\n                } else if (type >= BEVEL && type < BEVEL + 1.5) {\r\n                    float d2 = side / resolution;\r\n                    if (vertexNum < 6.5) {\r\n                        pos = (shift + dy) * norm + d2 * norm3;\r\n                    } else {\r\n                        pos = (shift + dy) * norm2 + d2 * norm3;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (type >= ROUND && type < ROUND + 1.5) {\r\n                vArc.x = side * dot(pos, norm3);\r\n                vArc.y = pos.x * norm3.y - pos.y * norm3.x;\r\n                vArc.z = dot(norm, norm3) * (lineWidth + side * shift);\r\n                vArc.w = lineWidth + side * shift;\r\n                vType = 3.0;\r\n            } else if (type >= MITER && type < MITER + 3.5) {\r\n                vType = 1.0;\r\n            } else if (type >= BEVEL && type < BEVEL + 1.5) {\r\n                vType = 4.0;\r\n                vArc.z = dot(norm, norm3) * (lineWidth + side * shift) - side * dot(pos, norm3);\r\n            }\r\n\r\n            dy = side * (dot(pos, norm) - shift);\r\n            dy2 = side * (dot(pos, norm2) - shift);\r\n        }\r\n\r\n        pos += base;\r\n        vLine1.xy = vec2(dy, vLine1.y) * resolution;\r\n        vLine2.xy = vec2(dy2, vLine2.y) * resolution;\r\n        vArc = vArc * resolution;\r\n        vTravel = vec2(aTravel * avgScale + dot(pos - pointA, vec2(-norm.y, norm.x)), avgScale);\r\n    }\r\n\r\n    gl_Position = vec4((projectionMatrix * vec3(pos, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vColor = aColor * tint;\r\n}`;\r\n\r\nconst precision = `#version 100\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n  precision highp float;\r\n#else\r\n  precision mediump float;\r\n#endif\r\n`;\r\n\r\nconst smoothFrag = `%PRECISION%\r\nvarying vec4 vColor;\r\nvarying vec4 vLine1;\r\nvarying vec4 vLine2;\r\nvarying vec4 vArc;\r\nvarying float vType;\r\nvarying float vTextureId;\r\nvarying vec2 vTextureCoord;\r\nvarying vec2 vTravel;\r\nuniform sampler2D uSamplers[%MAX_TEXTURES%];\r\n\r\n%PIXEL_LINE%\r\n\r\nvoid main(void){\r\n    %PIXEL_COVERAGE%\r\n\r\n    vec4 texColor;\r\n    float textureId = floor(vTextureId+0.5);\r\n    %FOR_LOOP%\r\n\r\n    gl_FragColor = vColor * texColor * alpha;\r\n}\r\n`;\r\n\r\nconst pixelLineFunc = [`\r\nfloat pixelLine(float x, float A, float B) {\r\n    return clamp(x + 0.5, 0.0, 1.0);\r\n}\r\n`, `\r\nfloat pixelLine(float x, float A, float B) {\r\n    float y = abs(x), s = sign(x);\r\n    if (y * 2.0 < A - B) {\r\n        return 0.5 + s * y / A;\r\n    }\r\n    y -= (A - B) * 0.5;\r\n    y = max(1.0 - y / B, 0.0);\r\n    return (1.0 + s * (1.0 - y * y)) * 0.5;\r\n    //return clamp(x + 0.5, 0.0, 1.0);\r\n}\r\n`];\r\n\r\nconst pixelCoverage = `float alpha = 1.0;\r\nif (vType < 0.5) {\r\n    float left = pixelLine(-vLine1.y - vLine1.x, vLine1.z, vLine1.w);\r\n    float right = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);\r\n    float near = vLine2.x - 0.5;\r\n    float far = min(vLine2.x + 0.5, 0.0);\r\n    float top = vLine2.y - 0.5;\r\n    float bottom = min(vLine2.y + 0.5, 0.0);\r\n    alpha = (right - left) * max(bottom - top, 0.0) * max(far - near, 0.0);\r\n} else if (vType < 1.5) {\r\n    float a1 = pixelLine(- vLine1.y - vLine1.x, vLine1.z, vLine1.w);\r\n    float a2 = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);\r\n    float b1 = pixelLine(- vLine2.y - vLine2.x, vLine2.z, vLine2.w);\r\n    float b2 = pixelLine(vLine2.y - vLine2.x, vLine2.z, vLine2.w);\r\n    alpha = a2 * b2 - a1 * b1;\r\n} else if (vType < 2.5) {\r\n    alpha *= max(min(vLine1.x + 0.5, 1.0), 0.0);\r\n    alpha *= max(min(vLine1.y + 0.5, 1.0), 0.0);\r\n    alpha *= max(min(vLine1.z + 0.5, 1.0), 0.0);\r\n} else if (vType < 3.5) {\r\n    float a1 = pixelLine(- vLine1.y - vLine1.x, vLine1.z, vLine1.w);\r\n    float a2 = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);\r\n    float b1 = pixelLine(- vLine2.y - vLine2.x, vLine2.z, vLine2.w);\r\n    float b2 = pixelLine(vLine2.y - vLine2.x, vLine2.z, vLine2.w);\r\n    float alpha_miter = a2 * b2 - a1 * b1;\r\n    float alpha_plane = clamp(vArc.z - vArc.x + 0.5, 0.0, 1.0);\r\n    float d = length(vArc.xy);\r\n    float circle_hor = max(min(vArc.w, d + 0.5) - max(-vArc.w, d - 0.5), 0.0);\r\n    float circle_vert = min(vArc.w * 2.0, 1.0);\r\n    float alpha_circle = circle_hor * circle_vert;\r\n    alpha = min(alpha_miter, max(alpha_circle, alpha_plane));\r\n} else {\r\n    float a1 = pixelLine(- vLine1.y - vLine1.x, vLine1.z, vLine1.w);\r\n    float a2 = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);\r\n    float b1 = pixelLine(- vLine2.y - vLine2.x, vLine2.z, vLine2.w);\r\n    float b2 = pixelLine(vLine2.y - vLine2.x, vLine2.z, vLine2.w);\r\n    alpha = a2 * b2 - a1 * b1;\r\n    alpha *= clamp(vArc.z + 0.5, 0.0, 1.0);\r\n}\r\n`;\r\n\r\n/**\r\n * @memberof PIXI.smooth\r\n */\r\nexport class SmoothGraphicsShader extends Shader\r\n{\r\n    settings: IGraphicsBatchSettings;\r\n\r\n    constructor(settings: IGraphicsBatchSettings,\r\n        vert = smoothVert,\r\n        frag = smoothFrag,\r\n        uniforms = {})\r\n    {\r\n        vert = SmoothGraphicsShader.generateVertexSrc(settings, vert);\r\n        frag = SmoothGraphicsShader.generateFragmentSrc(settings, frag);\r\n\r\n        const { maxStyles, maxTextures } = settings;\r\n        const sampleValues = new Int32Array(maxTextures);\r\n\r\n        for (let i = 0; i < maxTextures; i++)\r\n        {\r\n            sampleValues[i] = i;\r\n        }\r\n        super(Program.from(vert, frag), (Object as any).assign(uniforms, {\r\n            styleMatrix: new Float32Array(6 * maxStyles),\r\n            styleTextureId: new Float32Array(maxStyles),\r\n            styleLine: new Float32Array(2 * maxStyles),\r\n            samplerSize: new Float32Array(2 * maxTextures),\r\n            uSamplers: sampleValues,\r\n            tint: new Float32Array([1, 1, 1, 1]),\r\n            resolution: 1,\r\n            expand: 1,\r\n        }));\r\n        this.settings = settings;\r\n    }\r\n\r\n    static generateVertexSrc(settings: IGraphicsBatchSettings, vertexSrc = smoothVert): string\r\n    {\r\n        const { maxStyles, maxTextures } = settings;\r\n\r\n        vertexSrc = vertexSrc.replace(/%MAX_TEXTURES%/gi, `${maxTextures}`)\r\n            .replace(/%MAX_STYLES%/gi, `${maxStyles}`);\r\n\r\n        return vertexSrc;\r\n    }\r\n\r\n    static generateFragmentSrc(settings: IGraphicsBatchSettings, fragmentSrc = smoothFrag): string\r\n    {\r\n        const { maxTextures, pixelLine } = settings;\r\n\r\n        fragmentSrc = fragmentSrc.replace(/%PRECISION%/gi, precision)\r\n            .replace(/%PIXEL_LINE%/gi, pixelLineFunc[pixelLine])\r\n            .replace(/%PIXEL_COVERAGE%/gi, pixelCoverage)\r\n            .replace(/%MAX_TEXTURES%/gi, `${maxTextures}`)\r\n            .replace(/%FOR_LOOP%/gi, this.generateSampleSrc(maxTextures));\r\n\r\n        return fragmentSrc;\r\n    }\r\n\r\n    static generateSampleSrc(maxTextures: number): string\r\n    {\r\n        let src = '';\r\n\r\n        src += '\\n';\r\n        src += '\\n';\r\n\r\n        for (let i = 0; i < maxTextures; i++)\r\n        {\r\n            if (i > 0)\r\n            {\r\n                src += '\\nelse ';\r\n            }\r\n\r\n            if (i < maxTextures - 1)\r\n            {\r\n                src += `if(textureId < ${i}.5)`;\r\n            }\r\n\r\n            src += '\\n{';\r\n            src += `\\n\\ttexColor = texture2D(uSamplers[${i}], vTextureCoord);`;\r\n            src += '\\n}';\r\n        }\r\n\r\n        src += '\\n';\r\n        src += '\\n';\r\n\r\n        return src;\r\n    }\r\n}\r\n"],"names":["Shader","Program"],"mappings":";;;;AAGA,MAAM,UAAa,GAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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"}