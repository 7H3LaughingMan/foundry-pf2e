{"version":3,"file":"SmoothGraphicsGeometry.mjs","sources":["../src/SmoothGraphicsGeometry.ts"],"sourcesContent":["import { SmoothGraphicsData } from './core/SmoothGraphicsData';\r\n\r\nimport { FILL_COMMANDS } from './shapes';\r\n\r\nimport {\r\n    Buffer,\r\n    Color,\r\n    Geometry,\r\n    Texture,\r\n    WRAP_MODES,\r\n    TYPES,\r\n    SHAPES,\r\n    Point,\r\n    Matrix,\r\n} from '@pixi/core';\r\n\r\nimport { Bounds } from '@pixi/display';\r\n\r\nimport type { Circle, Ellipse, Polygon, Rectangle, RoundedRectangle, IPointData } from '@pixi/core';\r\nimport { BuildData } from './core/BuildData';\r\nimport { SegmentPacker } from './core/SegmentPacker';\r\nimport { LineStyle } from './core/LineStyle';\r\nimport { FillStyle } from './core/FillStyle';\r\nimport { BatchPart } from './core/BatchPart';\r\nimport { BatchDrawCall, IGraphicsBatchSettings, matrixEquals } from './core/BatchDrawCall';\r\n\r\n/*\r\n * Complex shape type\r\n * @todo Move to Math shapes\r\n */\r\nexport type IShape = Circle | Ellipse | Polygon | Rectangle | RoundedRectangle;\r\n\r\nexport const BATCH_POOL: Array<BatchPart> = [];\r\nexport const DRAW_CALL_POOL: Array<BatchDrawCall> = [];\r\n\r\nconst tmpPoint = new Point();\r\nconst tmpBounds = new Bounds();\r\n\r\n/**\r\n * @memberof PIXI.smooth\r\n */\r\nexport class SmoothGraphicsGeometry extends Geometry\r\n{\r\n    public static BATCHABLE_SIZE = 100;\r\n\r\n    public boundsPadding: number;\r\n\r\n    indicesUint16: Uint16Array | Uint32Array = null;\r\n    batchable: boolean;\r\n\r\n    buildData: BuildData;\r\n\r\n    get points()\r\n    {\r\n        return this.buildData.verts;\r\n    }\r\n\r\n    get closePointEps()\r\n    {\r\n        return this.buildData.closePointEps;\r\n    }\r\n\r\n    graphicsData: Array<SmoothGraphicsData>;\r\n    drawCalls: Array<BatchDrawCall>;\r\n    batchDirty: number;\r\n    batches: Array<BatchPart>;\r\n    packer: SegmentPacker;\r\n    packSize: number;\r\n    pack32index: boolean;\r\n    strideFloats: number;\r\n\r\n    protected dirty: number;\r\n    protected cacheDirty: number;\r\n    protected clearDirty: number;\r\n    protected shapeBuildIndex: number;\r\n    protected shapeBatchIndex: number;\r\n    protected _bounds: Bounds;\r\n    protected boundsDirty: number;\r\n\r\n    _buffer: Buffer;\r\n    _indexBuffer: Buffer;\r\n    _bufferFloats: Float32Array;\r\n    _bufferUint: Uint32Array;\r\n\r\n    initAttributes(_static: boolean)\r\n    {\r\n        this._buffer = new Buffer(null, _static, false);\r\n        this._bufferFloats = new Float32Array();\r\n        this._bufferUint = new Uint32Array();\r\n\r\n        this._indexBuffer = new Buffer(null, _static, true);\r\n        this.addAttribute('aPrev', this._buffer, 2, false, TYPES.FLOAT)\r\n            .addAttribute('aPoint1', this._buffer, 2, false, TYPES.FLOAT)\r\n            .addAttribute('aPoint2', this._buffer, 2, false, TYPES.FLOAT)\r\n            .addAttribute('aNext', this._buffer, 2, false, TYPES.FLOAT)\r\n            .addAttribute('aTravel', this._buffer, 1, false, TYPES.FLOAT)\r\n            // number of vertex\r\n            .addAttribute('aVertexJoint', this._buffer, 1, false, TYPES.FLOAT)\r\n            // line width, alignment\r\n            .addAttribute('aStyleId', this._buffer, 1, false, TYPES.FLOAT)\r\n            // the usual\r\n            .addAttribute('aColor', this._buffer, 4, true, TYPES.UNSIGNED_BYTE)\r\n            .addIndex(this._indexBuffer);\r\n\r\n        this.strideFloats = 12;\r\n    }\r\n\r\n    constructor()\r\n    {\r\n        super();\r\n\r\n        this.initAttributes(false);\r\n\r\n        this.buildData = new BuildData();\r\n\r\n        this.graphicsData = [];\r\n\r\n        this.dirty = 0;\r\n\r\n        this.batchDirty = -1;\r\n\r\n        this.cacheDirty = -1;\r\n\r\n        this.clearDirty = 0;\r\n\r\n        this.drawCalls = [];\r\n\r\n        this.batches = [];\r\n\r\n        this.shapeBuildIndex = 0;\r\n\r\n        this.shapeBatchIndex = 0;\r\n\r\n        this._bounds = new Bounds();\r\n\r\n        this.boundsDirty = -1;\r\n\r\n        this.boundsPadding = 0;\r\n\r\n        this.batchable = false;\r\n\r\n        this.indicesUint16 = null;\r\n\r\n        this.packer = null;\r\n        this.packSize = 0;\r\n        this.pack32index = null;\r\n    }\r\n\r\n    public checkInstancing(instanced: boolean, allow32Indices: boolean)\r\n    {\r\n        if (this.packer)\r\n        {\r\n            return;\r\n        }\r\n        this.packer = new SegmentPacker();\r\n        this.pack32index = allow32Indices;\r\n    }\r\n\r\n    /**\r\n     * Get the current bounds of the graphic geometry.\r\n     *\r\n     * @member {PIXI.Bounds}\r\n     * @readonly\r\n     */\r\n    public get bounds(): Bounds\r\n    {\r\n        if (this.boundsDirty !== this.dirty)\r\n        {\r\n            this.boundsDirty = this.dirty;\r\n            this.calculateBounds();\r\n        }\r\n\r\n        return this._bounds;\r\n    }\r\n\r\n    /**\r\n     * Call if you changed graphicsData manually.\r\n     * Empties all batch buffers.\r\n     */\r\n    protected invalidate(): void\r\n    {\r\n        this.boundsDirty = -1;\r\n        this.dirty++;\r\n        this.batchDirty++;\r\n        this.shapeBuildIndex = 0;\r\n        this.shapeBatchIndex = 0;\r\n        this.packSize = 0;\r\n\r\n        this.buildData.clear();\r\n\r\n        for (let i = 0; i < this.drawCalls.length; i++)\r\n        {\r\n            this.drawCalls[i].clear();\r\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\r\n        }\r\n\r\n        this.drawCalls.length = 0;\r\n\r\n        for (let i = 0; i < this.batches.length; i++)\r\n        {\r\n            const batchPart = this.batches[i];\r\n\r\n            batchPart.reset();\r\n            BATCH_POOL.push(batchPart);\r\n        }\r\n\r\n        this.batches.length = 0;\r\n    }\r\n\r\n    public clear(): SmoothGraphicsGeometry\r\n    {\r\n        if (this.graphicsData.length > 0)\r\n        {\r\n            this.invalidate();\r\n            this.clearDirty++;\r\n            this.graphicsData.length = 0;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public drawShape(\r\n        shape: IShape,\r\n        fillStyle: FillStyle = null,\r\n        lineStyle: LineStyle = null,\r\n        matrix: Matrix = null): SmoothGraphicsGeometry\r\n    {\r\n        const data = new SmoothGraphicsData(shape, fillStyle, lineStyle, matrix);\r\n\r\n        this.graphicsData.push(data);\r\n        this.dirty++;\r\n\r\n        return this;\r\n    }\r\n\r\n    public drawHole(shape: IShape, matrix: Matrix = null): SmoothGraphicsGeometry\r\n    {\r\n        if (!this.graphicsData.length)\r\n        {\r\n            return null;\r\n        }\r\n\r\n        const data = new SmoothGraphicsData(shape, null, null, matrix);\r\n\r\n        const lastShape = this.graphicsData[this.graphicsData.length - 1];\r\n\r\n        data.lineStyle = lastShape.lineStyle;\r\n\r\n        lastShape.holes.push(data);\r\n\r\n        this.dirty++;\r\n\r\n        return this;\r\n    }\r\n\r\n    public destroy(): void\r\n    {\r\n        super.destroy();\r\n\r\n        // destroy each of the SmoothGraphicsData objects\r\n        for (let i = 0; i < this.graphicsData.length; ++i)\r\n        {\r\n            this.graphicsData[i].destroy();\r\n        }\r\n\r\n        this.buildData.destroy();\r\n        this.buildData = null;\r\n        this.indexBuffer.destroy();\r\n        this.indexBuffer = null;\r\n        this.graphicsData.length = 0;\r\n        this.graphicsData = null;\r\n        this.drawCalls.length = 0;\r\n        this.drawCalls = null;\r\n        this.batches.length = 0;\r\n        this.batches = null;\r\n        this._bounds = null;\r\n    }\r\n\r\n    /**\r\n     * Check to see if a point is contained within this geometry.\r\n     *\r\n     * @param {PIXI.IPointData} point - Point to check if it's contained.\r\n     * @return {Boolean} `true` if the point is contained within geometry.\r\n     */\r\n    public containsPoint(point: IPointData): boolean\r\n    {\r\n        const graphicsData = this.graphicsData;\r\n\r\n        for (let i = 0; i < graphicsData.length; ++i)\r\n        {\r\n            const data = graphicsData[i];\r\n\r\n            if (!data.fillStyle.visible)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            // only deal with fills..\r\n            if (data.shape)\r\n            {\r\n                if (data.matrix)\r\n                {\r\n                    data.matrix.applyInverse(point, tmpPoint);\r\n                }\r\n                else\r\n                {\r\n                    tmpPoint.copyFrom(point);\r\n                }\r\n\r\n                if (data.shape.contains(tmpPoint.x, tmpPoint.y))\r\n                {\r\n                    let hitHole = false;\r\n\r\n                    if (data.holes)\r\n                    {\r\n                        for (let i = 0; i < data.holes.length; i++)\r\n                        {\r\n                            const hole = data.holes[i];\r\n\r\n                            if (hole.shape.contains(tmpPoint.x, tmpPoint.y))\r\n                            {\r\n                                hitHole = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (!hitHole)\r\n                    {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    updatePoints(): void\r\n    {\r\n        // do nothing\r\n    }\r\n\r\n    updateBufferSize(): void\r\n    {\r\n        this._buffer.update(new Float32Array());\r\n    }\r\n\r\n    updateBuild(): void\r\n    {\r\n        const { graphicsData, buildData } = this;\r\n        const len = graphicsData.length;\r\n\r\n        for (let i = this.shapeBuildIndex; i < len; i++)\r\n        {\r\n            const data = graphicsData[i];\r\n\r\n            data.strokeStart = 0;\r\n            data.strokeLen = 0;\r\n            data.fillStart = 0;\r\n            data.fillLen = 0;\r\n            const { fillStyle, lineStyle, holes } = data;\r\n\r\n            if (!fillStyle.visible && !lineStyle.visible)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            const command = FILL_COMMANDS[data.type];\r\n\r\n            data.clearPath();\r\n\r\n            command.path(data, buildData);\r\n            if (data.matrix)\r\n            {\r\n                this.transformPoints(data.points, data.matrix);\r\n            }\r\n\r\n            data.clearBuild();\r\n            if (data.points.length <= 2)\r\n            {\r\n                continue;\r\n            }\r\n            if (fillStyle.visible || lineStyle.visible)\r\n            {\r\n                this.processHoles(holes);\r\n            }\r\n            if (fillStyle.visible)\r\n            {\r\n                data.fillAA = (data.fillStyle as any).smooth\r\n                    && data.fillStyle.texture === Texture.WHITE\r\n                    && holes.length === 0\r\n                    && !(data.closeStroke\r\n                    && data.lineStyle.visible\r\n                    && !data.lineStyle.shader\r\n                    && data.lineStyle.alpha >= 0.99\r\n                    && data.lineStyle.width * Math.min(data.lineStyle.alignment, 1 - data.lineStyle.alignment) >= 0.495);\r\n\r\n                data.fillStart = buildData.joints.length;\r\n\r\n                if (holes.length)\r\n                {\r\n                    FILL_COMMANDS[SHAPES.POLY].fill(data, buildData);\r\n                }\r\n                else\r\n                {\r\n                    command.fill(data, buildData);\r\n                }\r\n\r\n                data.fillLen = buildData.joints.length - data.fillStart;\r\n            }\r\n            if (lineStyle.visible)\r\n            {\r\n                data.strokeStart = buildData.joints.length;\r\n                command.line(data, buildData);\r\n                for (let i = 0; i < holes.length; i++)\r\n                {\r\n                    const hole = holes[i];\r\n\r\n                    FILL_COMMANDS[hole.type].line(hole, buildData);\r\n                }\r\n                data.strokeLen = buildData.joints.length - data.strokeStart;\r\n            }\r\n        }\r\n        this.shapeBuildIndex = len;\r\n    }\r\n\r\n    updateBatches(shaderSettings?: IGraphicsBatchSettings): void\r\n    {\r\n        if (!this.graphicsData.length)\r\n        {\r\n            this.batchable = true;\r\n\r\n            return;\r\n        }\r\n        this.updateBuild();\r\n\r\n        if (!this.validateBatching())\r\n        {\r\n            return;\r\n        }\r\n\r\n        const { buildData, graphicsData } = this;\r\n        const len = graphicsData.length;\r\n\r\n        this.cacheDirty = this.dirty;\r\n\r\n        let batchPart: BatchPart = null;\r\n\r\n        let currentStyle = null;\r\n\r\n        if (this.batches.length > 0)\r\n        {\r\n            batchPart = this.batches[this.batches.length - 1];\r\n            currentStyle = batchPart.style;\r\n        }\r\n\r\n        for (let i = this.shapeBatchIndex; i < len; i++)\r\n        {\r\n            const data = graphicsData[i];\r\n            const fillStyle = data.fillStyle;\r\n            const lineStyle = data.lineStyle;\r\n\r\n            if (data.matrix)\r\n            {\r\n                this.transformPoints(data.points, data.matrix);\r\n            }\r\n            if (!fillStyle.visible && !lineStyle.visible)\r\n            {\r\n                continue;\r\n            }\r\n            for (let j = 0; j < 2; j++)\r\n            {\r\n                const style = (j === 0) ? fillStyle : lineStyle;\r\n\r\n                if (!style.visible) continue;\r\n\r\n                const nextTexture = style.texture.baseTexture;\r\n                const attribOld = buildData.vertexSize;\r\n                const indexOld = buildData.indexSize;\r\n\r\n                nextTexture.wrapMode = WRAP_MODES.REPEAT;\r\n                if (j === 0)\r\n                {\r\n                    this.packer.updateBufferSize(data.fillStart, data.fillLen, data.triangles.length, buildData);\r\n                }\r\n                else\r\n                {\r\n                    this.packer.updateBufferSize(data.strokeStart, data.strokeLen, data.triangles.length, buildData);\r\n                }\r\n\r\n                const attribSize = buildData.vertexSize;\r\n\r\n                if (attribSize === attribOld) continue;\r\n                // close batch if style is different\r\n                if (batchPart && !this._compareStyles(currentStyle, style))\r\n                {\r\n                    batchPart.end(indexOld, attribOld);\r\n                    batchPart = null;\r\n                }\r\n                // spawn new batch if its first batch or previous was closed\r\n                if (!batchPart)\r\n                {\r\n                    batchPart = BATCH_POOL.pop() || new BatchPart();\r\n                    batchPart.begin(style, indexOld, attribOld);\r\n                    this.batches.push(batchPart);\r\n                    currentStyle = style;\r\n                }\r\n\r\n                if (j === 0)\r\n                {\r\n                    batchPart.jointEnd = data.fillStart + data.fillLen;\r\n                }\r\n                else\r\n                {\r\n                    batchPart.jointEnd = data.strokeStart + data.strokeLen;\r\n                }\r\n            }\r\n        }\r\n        this.shapeBatchIndex = len;\r\n\r\n        if (batchPart)\r\n        {\r\n            batchPart.end(buildData.indexSize, buildData.vertexSize);\r\n        }\r\n\r\n        if (this.batches.length === 0)\r\n        {\r\n            // there are no visible styles in SmoothGraphicsData\r\n            // its possible that someone wants Graphics just for the bounds\r\n            this.batchable = true;\r\n\r\n            return;\r\n        }\r\n\r\n        // TODO make this a const..\r\n        this.batchable = this.isBatchable();\r\n\r\n        if (this.batchable)\r\n        {\r\n            this.packBatches();\r\n        }\r\n        else\r\n        {\r\n            this.buildDrawCalls(shaderSettings);\r\n            this.updatePack();\r\n        }\r\n    }\r\n\r\n    updatePack()\r\n    {\r\n        const { vertexSize, indexSize } = this.buildData;\r\n\r\n        if (this.packSize === vertexSize)\r\n        {\r\n            return;\r\n        }\r\n\r\n        const { strideFloats, packer, buildData, batches } = this;\r\n        const buffer = this._buffer;\r\n        const index = this._indexBuffer;\r\n        const floatsSize = vertexSize * strideFloats;\r\n\r\n        if (buffer.data.length !== floatsSize)\r\n        {\r\n            const arrBuf = new ArrayBuffer(floatsSize * 4);\r\n\r\n            this._bufferFloats = new Float32Array(arrBuf);\r\n            this._bufferUint = new Uint32Array(arrBuf);\r\n            buffer.data = this._bufferFloats;\r\n        }\r\n        if (index.data.length !== indexSize)\r\n        {\r\n            if (vertexSize > 0xffff && this.pack32index)\r\n            {\r\n                index.data = new Uint32Array(indexSize);\r\n            }\r\n            else\r\n            {\r\n                index.data = new Uint16Array(indexSize);\r\n            }\r\n        }\r\n\r\n        packer.beginPack(buildData, this._bufferFloats, this._bufferUint, index.data as Uint16Array);\r\n\r\n        let j = 0;\r\n\r\n        for (let i = 0; i < this.graphicsData.length; i++)\r\n        {\r\n            const data = this.graphicsData[i];\r\n\r\n            if (data.fillLen)\r\n            {\r\n                while (batches[j].jointEnd <= data.fillStart)\r\n                {\r\n                    j++;\r\n                }\r\n                packer.packInterleavedGeometry(data.fillStart, data.fillLen, data.triangles,\r\n                    batches[j].styleId, batches[j].rgba);\r\n            }\r\n            if (data.strokeLen)\r\n            {\r\n                while (batches[j].jointEnd <= data.strokeStart)\r\n                {\r\n                    j++;\r\n                }\r\n                packer.packInterleavedGeometry(data.strokeStart, data.strokeLen, data.triangles,\r\n                    batches[j].styleId, batches[j].rgba);\r\n            }\r\n        }\r\n\r\n        buffer.update();\r\n        index.update();\r\n        this.packSize = vertexSize;\r\n    }\r\n\r\n    /**\r\n     * Affinity check\r\n     *\r\n     * @param {PIXI.FillStyle | PIXI.LineStyle} styleA\r\n     * @param {PIXI.FillStyle | PIXI.LineStyle} styleB\r\n     */\r\n    protected _compareStyles(styleA: FillStyle | LineStyle, styleB: FillStyle | LineStyle): boolean\r\n    {\r\n        if (!styleA || !styleB)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        if (styleA.texture.baseTexture !== styleB.texture.baseTexture)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        if (styleA.shader !== styleB.shader)\r\n        {\r\n            return false;\r\n        }\r\n        // TODO: propagate width for FillStyle\r\n        if ((styleA as LineStyle).width !== (styleB as LineStyle).width)\r\n        {\r\n            return false;\r\n        }\r\n        if ((styleA as LineStyle).scaleMode !== (styleB as LineStyle).scaleMode)\r\n        {\r\n            return false;\r\n        }\r\n        if ((styleA as LineStyle).alignment !== (styleB as LineStyle).alignment)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        const mat1 = styleA.matrix || Matrix.IDENTITY;\r\n        const mat2 = styleB.matrix || Matrix.IDENTITY;\r\n\r\n        return matrixEquals(mat1, mat2);\r\n    }\r\n\r\n    /**\r\n     * Test geometry for batching process.\r\n     *\r\n     * @protected\r\n     */\r\n    protected validateBatching(): boolean\r\n    {\r\n        if (this.dirty === this.cacheDirty || !this.graphicsData.length)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        for (let i = 0, l = this.graphicsData.length; i < l; i++)\r\n        {\r\n            const data = this.graphicsData[i];\r\n            const fill = data.fillStyle;\r\n            const line = data.lineStyle;\r\n\r\n            if (fill && !fill.texture.baseTexture.valid) return false;\r\n            if (line && !line.texture.baseTexture.valid) return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Offset the indices so that it works with the batcher.\r\n     *\r\n     * @protected\r\n     */\r\n    protected packBatches(): void\r\n    {\r\n        this.batchDirty++;\r\n        const batches = this.batches;\r\n\r\n        for (let i = 0, l = batches.length; i < l; i++)\r\n        {\r\n            const batch = batches[i];\r\n\r\n            for (let j = 0; j < batch.size; j++)\r\n            {\r\n                const index = batch.start + j;\r\n\r\n                this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\r\n            }\r\n        }\r\n    }\r\n\r\n    protected isBatchable(): boolean\r\n    {\r\n        return false;\r\n\r\n        // prevent heavy mesh batching\r\n        // if (this.points.length > 0xffff * 2) {\r\n        //     return false;\r\n        // }\r\n        //\r\n        // const batches = this.batches;\r\n        //\r\n        // for (let i = 0; i < batches.length; i++) {\r\n        //     if ((batches[i].style as LineStyle).native) {\r\n        //         return false;\r\n        //     }\r\n        // }\r\n        //\r\n        // return (this.points.length < SmoothGraphicsGeometry.BATCHABLE_SIZE * 2);\r\n    }\r\n\r\n    /**\r\n     * Converts intermediate batches data to drawCalls.\r\n     *\r\n     * @protected\r\n     */\r\n    protected buildDrawCalls(shaderSettings?: IGraphicsBatchSettings)\r\n    {\r\n        for (let i = 0; i < this.drawCalls.length; i++)\r\n        {\r\n            this.drawCalls[i].clear();\r\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\r\n        }\r\n\r\n        this.drawCalls.length = 0;\r\n\r\n        let currentGroup = DRAW_CALL_POOL.pop() || new BatchDrawCall();\r\n\r\n        currentGroup.begin(shaderSettings, null);\r\n\r\n        let index = 0;\r\n\r\n        this.drawCalls.push(currentGroup);\r\n\r\n        for (let i = 0; i < this.batches.length; i++)\r\n        {\r\n            const batchData = this.batches[i];\r\n            const style = batchData.style as LineStyle;\r\n\r\n            if (batchData.attribSize === 0)\r\n            {\r\n                // I don't know how why do we have size=0 sometimes\r\n                continue;\r\n            }\r\n\r\n            let styleId = -1;\r\n            const mat = style.getTextureMatrix();\r\n\r\n            if (currentGroup.check(style.shader))\r\n            {\r\n                styleId = currentGroup.add(style.texture, mat,\r\n                    style.width, style.alignment || 0, style.packLineScale());\r\n            }\r\n            if (styleId < 0)\r\n            {\r\n                currentGroup = DRAW_CALL_POOL.pop() || new BatchDrawCall();\r\n                this.drawCalls.push(currentGroup);\r\n                currentGroup.begin(shaderSettings, style.shader);\r\n                currentGroup.start = index;\r\n                styleId = currentGroup.add(style.texture, mat,\r\n                    style.width, style.alignment || 0, style.packLineScale());\r\n            }\r\n            currentGroup.size += batchData.size;\r\n            index += batchData.size;\r\n\r\n            const { color, alpha } = style;\r\n            const bgr = Color.shared\r\n                .setValue(color)\r\n                .toLittleEndianNumber();\r\n\r\n            batchData.rgba = Color.shared\r\n                .setValue(bgr)\r\n                .toPremultiplied(alpha);\r\n            batchData.styleId = styleId;\r\n        }\r\n    }\r\n\r\n    protected processHoles(holes: Array<SmoothGraphicsData>): void\r\n    {\r\n        for (let i = 0; i < holes.length; i++)\r\n        {\r\n            const hole = holes[i];\r\n            const command = FILL_COMMANDS[hole.type];\r\n\r\n            hole.clearPath();\r\n\r\n            command.path(hole, this.buildData);\r\n\r\n            if (hole.matrix)\r\n            {\r\n                this.transformPoints(hole.points, hole.matrix);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the local bounds of the object. Expensive to use performance-wise.\r\n     *\r\n     * @protected\r\n     */\r\n    protected calculateBounds(): void\r\n    {\r\n        const bounds = this._bounds;\r\n        const sequenceBounds = tmpBounds;\r\n        let curMatrix = Matrix.IDENTITY;\r\n\r\n        this._bounds.clear();\r\n        sequenceBounds.clear();\r\n\r\n        for (let i = 0; i < this.graphicsData.length; i++)\r\n        {\r\n            const data = this.graphicsData[i];\r\n            const shape = data.shape;\r\n            const type = data.type;\r\n            const lineStyle = data.lineStyle;\r\n            const nextMatrix = data.matrix || Matrix.IDENTITY;\r\n            let lineWidth = 0.0;\r\n\r\n            if (lineStyle && lineStyle.visible)\r\n            {\r\n                lineWidth = lineStyle.width;\r\n\r\n                if (type !== SHAPES.POLY || data.fillStyle.visible)\r\n                {\r\n                    lineWidth *= Math.max(0, lineStyle.alignment);\r\n                }\r\n                else\r\n                {\r\n                    lineWidth *= Math.max(lineStyle.alignment, 1 - lineStyle.alignment);\r\n                }\r\n            }\r\n\r\n            if (curMatrix !== nextMatrix)\r\n            {\r\n                if (!sequenceBounds.isEmpty())\r\n                {\r\n                    bounds.addBoundsMatrix(sequenceBounds, curMatrix);\r\n                    sequenceBounds.clear();\r\n                }\r\n                curMatrix = nextMatrix;\r\n            }\r\n\r\n            if (type === SHAPES.RECT || type === SHAPES.RREC)\r\n            {\r\n                const rect = shape as Rectangle | RoundedRectangle;\r\n\r\n                sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height,\r\n                    lineWidth, lineWidth);\r\n            }\r\n            else if (type === SHAPES.CIRC)\r\n            {\r\n                const circle = shape as Circle;\r\n\r\n                sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y,\r\n                    circle.radius + lineWidth, circle.radius + lineWidth);\r\n            }\r\n            else if (type === SHAPES.ELIP)\r\n            {\r\n                const ellipse = shape as Ellipse;\r\n\r\n                sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y,\r\n                    ellipse.width + lineWidth, ellipse.height + lineWidth);\r\n            }\r\n            else\r\n            {\r\n                const poly = shape as Polygon;\r\n                // adding directly to the bounds\r\n\r\n                bounds.addVerticesMatrix(curMatrix, (poly.points as any), 0, poly.points.length, lineWidth, lineWidth);\r\n            }\r\n        }\r\n\r\n        if (!sequenceBounds.isEmpty())\r\n        {\r\n            bounds.addBoundsMatrix(sequenceBounds, curMatrix);\r\n        }\r\n\r\n        bounds.pad(this.boundsPadding, this.boundsPadding);\r\n    }\r\n\r\n    /**\r\n     * Transform points using matrix.\r\n     *\r\n     * @protected\r\n     * @param {number[]} points - Points to transform\r\n     * @param {PIXI.Matrix} matrix - Transform matrix\r\n     */\r\n    protected transformPoints(points: Array<number>, matrix: Matrix): void\r\n    {\r\n        for (let i = 0; i < points.length / 2; i++)\r\n        {\r\n            const x = points[(i * 2)];\r\n            const y = points[(i * 2) + 1];\r\n\r\n            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;\r\n            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;\r\n        }\r\n    }\r\n}\r\n"],"names":["i"],"mappings":"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"}